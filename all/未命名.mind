{"root":{"data":{"id":"d7zuph5gb8g0","created":1740316487249,"text":"MySQL","priority":null},"children":[{"data":{"id":"d7zupj5ub3k0","created":1740316491626,"text":"存储引擎","expandState":"collapse"},"children":[{"data":{"id":"d7zutfsrejc0","created":1740316797762,"text":"innoDB","expandState":"collapse"},"children":[{"data":{"id":"d7zuwsjz0go0","created":1740317060621,"text":"1.支持事务（一个事务就是一组不可分割的数据库操作，要么全部成功要么全部失败）、行级锁（允许对单个记录进行锁定，不影响表中其他行被其他事务访问或修改，提供高并发性能）和外键（一般互联网项目都不使用外键，不稳定）"},"children":[]},{"data":{"id":"d7zuwsjzv6g0","created":1740317060622,"text":"2.数据以聚簇索引的方式存储，提高检索效率"},"children":[{"data":{"id":"d7zuwsjzy540","created":1740317060622,"text":"聚簇索引："},"children":[{"data":{"id":"d7zuwsjzt940","created":1740317060622,"text":"索引叶子结点存储的是数据行，可以直接访问完整数据。非叶子节点存储的是主键（也可以说是主键值，索引键值【因为它默认使用主键当索引键】，它存储主键的范围值，如【1，5】，用于划分子节点的范围）和页号（也就是，指向子节点的指针）。"},"children":[]},{"data":{"id":"d7zuwsjzsmg0","created":1740317060622,"text":"每个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序。"},"children":[]}]},{"data":{"id":"d7zuwsjzjjs0","created":1740317060622,"text":"非聚簇索引："},"children":[{"data":{"id":"d7zuwsjzxls0","created":1740317060622,"text":"索引叶子节点存储的是数据行的主键和对应的索引列，需通过主键才能访问完整的数据行。非叶子节点存储的是主键（也可以说是主键值，索引键值【因为它默认使用主键当索引键】，它存储主键的范围值，如【1，5】，用于划分子节点的范围）和页号（也就是，指向子节点的指针）。。"},"children":[]},{"data":{"id":"d7zuwsjzy2o0","created":1740317060622,"text":"一个表可以有多个非聚簇索引（也称之为非主键索引、辅助索引、二级索引），适用于快速查找特定列的数据。"},"children":[]}]},{"data":{"id":"d7zuwsjzj800","created":1740317060622,"text":"关于回表"},"children":[{"data":{"id":"d7zuwsk0ahs0","created":1740317060623,"text":"那么什么是回表呢？简单来说，使用二级索引（非聚簇索引）作为查询条件的时候，由于它只存储索引字段的值和对应的主键值，无法获得其它的数据；如果需要查询数据行中的其它数据，需要根据关联的id回到聚簇索引中进行二次查询，这个过程就叫回表。"},"children":[{"data":{"id":"d7zuwsk0bm00","created":1740317060623,"text":"回表查询的详细过程："},"children":[{"data":{"id":"d7zuwsk059s0","created":1740317060623,"text":"1.在非聚簇索引的B+ Tree中查询，根据查询字段找到对应的叶子节点，获取里面的主键值"},"children":[]},{"data":{"id":"d7zuwsk069k0","created":1740317060623,"text":"2.在聚簇索引的B+ Tree中查询，根据第1步拿到的主键值定位对应的叶子节点，获取完整数据记录。"},"children":[]}]}]},{"data":{"id":"d7zuwsk021s0","created":1740317060623,"text":"回表的缺点"},"children":[{"data":{"id":"d7zuwsk0icw0","created":1740317060623,"text":"回表不仅仅意味着多查询一次，主要会带来随机I/O，因为回的时候，通过id去主键索引查询的时候，id肯定是不连续的（例如查询的是age=20，在age索引中年龄是有序的，但是对应的id是无序的），所以主键所以需要频繁查询会造成大量的随机I/O，随机I/O查询速度慢，所以频繁回表的效率低。表"},"children":[]}]},{"data":{"id":"d7zuwsk0h7s0","created":1740317060623,"text":"如何减少回表呢？"},"children":[{"data":{"id":"d7zuwsk01i80","created":1740317060623,"text":"1.索引覆盖"},"children":[{"data":{"id":"d7zuwsk02b40","created":1740317060623,"text":"简单理解，尽量少写select *这样的全查询，只写真正需要的列字段，避免引发不必要的回表操作。"},"children":[]},{"data":{"id":"d7zuwsk0h9s0","created":1740317060623,"text":"当使用非聚簇索引进行查询的时候，如果查询所需的列数据完全可以在所有中找到，而不需要回表（根据主键到聚簇索引里面进行查询），这种情况被称为索引覆盖。"},"children":[]}]},{"data":{"id":"d7zuwsk0fd40","created":1740317060623,"text":"2.索引下推(icp)"},"children":[{"data":{"id":"d7zuwsk072w0","created":1740317060623,"text":"索引下推是一种在联合索引上减少回表查询，提高查询效率的技术。它是5.6版本之后推出的一个概念。"},"children":[]},{"data":{"id":"d7zuwsjzzug0","created":1740317060623,"text":"它允许数据库存储引擎在存储层直接应用WHERE子句中的过滤条件，而不是将所有匹配数据行返回给查询处理层（server层）再进行过滤。因此它能在使用索引时减少回表查询次数，提高查询效率。"},"children":[]},{"data":{"id":"d7zuwsk0kc80","created":1740317060623,"text":"它允许MySQL在使用索引查找数据时，将WHERE字句中的过滤条件下推到存储引擎层过滤，从而减少需要从表中读取的数据行，减少了I/O（本该由Server层做操作，交由存储引擎层因此叫“下推”）。"},"children":[]}]}]}]}]},{"data":{"id":"d7zuwsk0g2w0","created":1740317060623,"text":"3.支持数据库崩溃后的安全恢复（通过redo log实现）"},"children":[]},{"data":{"id":"d7zuwsk0xiw0","created":1740317060624,"text":"4.适合的业务场景：高并发读写应用（如社交媒体账号、在线票务预订等等，利用行级锁机制有效减少锁冲突，提高并发处理能力）、事务处理系统（银行转账、电商订单处理等等，利用事务处理能力，保证数据的幂等性）、数据可靠性高的场景（如客户信息维护、财务数据等等，利用redo log的安全恢复机制）"},"children":[]}]},{"data":{"id":"d7zutjtgj6o0","created":1740316806511,"text":"myisam","expandState":"collapse"},"children":[{"data":{"id":"d7zux5jstew0","created":1740317088909,"text":"1.不支持外键和事务，不支持行级锁，支持表级锁（执行操作时会锁定整张表）"},"children":[]},{"data":{"id":"d7zux5jtsm80","created":1740317088910,"text":"2.索引文件和数据文件是分离的（即索引的叶子节点包含指向数据记录的指针）"},"children":[]},{"data":{"id":"d7zux5jtwd40","created":1740317088910,"text":"3.不支持数据库崩溃后的安全恢复"},"children":[]},{"data":{"id":"d7zux5jttiw0","created":1740317088910,"text":"4.适合的业务场景：读多写少的应用，读密集型应用（如新闻网站、博客系统等等，通常以读取数据为主）"},"children":[]}]}]},{"data":{"id":"d7zuxjlvdk00","created":1740317119509,"text":"关于索引","expandState":"expand"},"children":[{"data":{"id":"d7zuxjlw7g00","created":1740317119510,"text":"Mysql索引的最左前缀匹配原则是什么","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlw1ns0","created":1740317119510,"text":"简要回答：指的是在使用联合索引时，查询条件必须从索引的最左侧开始匹配。"},"children":[]},{"data":{"id":"d7zuxjlvv340","created":1740317119510,"text":"底层原理：mysql使用B+树做为索引结构，B+树有序，所以联合索引在B+树中遵循“从左往右”的顺序。"},"children":[]},{"data":{"id":"d7zuxjlw4y00","created":1740317119510,"text":"注意：如果遇到范围查询(>、<)，就会停止匹配。比如：where a>1, b=2, c=3;"},"children":[{"data":{"id":"d7zuxjlw3uo0","created":1740317119510,"text":"如果遇到如 >=、<=、BETWEEN、前缀like（xx%）的范围查询，则不会停止匹配。因为这些查询包含一个等值判断，可以直接定位到某个数据，然后往后扫描即可。例如：where a>=1, b=2, c=3;"},"children":[]}]},{"data":{"id":"d7zuxjlvtjc0","created":1740317119510,"text":"MySQL8中为什么有些场景不符合最左匹配原则也能走索引？"},"children":[{"data":{"id":"d7zuxjlvv540","created":1740317119510,"text":"Skip Scan Range Access Method机制：将缺失的左边值查出来，隐形拼接，就可以使用最左前缀原则了。"},"children":[]},{"data":{"id":"d7zuxjlwh680","created":1740317119511,"text":"MySQL 隐式的构造了查询条件，比如：idx_f2_f3的联合索引，where f3 =1的执行变成了where f2=1 and f3=1 和 where f2=2 and f3=1...，f2以此增加的联合索引查询了。"},"children":[]}]}]},{"data":{"id":"d7zuxjlwhyo0","created":1740317119511,"text":"B+树作为索引结构","expandState":"expand","progress":null,"resource":[],"layout":null},"children":[{"data":{"id":"d7zuxjlwvhs0","created":1740317119511,"text":"使用B+树的原因","layout":null},"children":[{"data":{"id":"d7zuxjlwvj40","created":1740317119511,"text":"1.高效的查找性能","layout":null},"children":[{"data":{"id":"d7zuxjlwlzk0","created":1740317119511,"text":"B+树是自平衡树，每个叶子节点到根节点的路径长度相同，B+树再插入和删除节点时会进行分裂和合并操作，以保持树的平衡。查找、插入、删除等操作的时间复杂度为 O(log n)。","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlwk740","created":1740317119511,"text":"2.查询磁盘的I/O次数减少","layout":null},"children":[{"data":{"id":"d7zuxjlwya80","created":1740317119511,"text":"能有效利用磁盘块的空间-树的高度低。因为叶子节点保存完整的数据，非叶子节点仅冗余数据（保存索引键和页面指针），因此内存就能存放更多的索引页，更容易命中缓存，使得查询磁盘的I/O次数减少。","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlwn7k0","created":1740317119511,"text":"3.范围查询能力强","layout":null},"children":[{"data":{"id":"d7zuxjlwxi00","created":1740317119511,"text":"B+树特别适合范围查询。因为叶子节点之间通过双向链表链接，从根节点查找到范围的起点后，只需要按顺序扫描链表就可以遍历后续的数据，不需要回溯到非叶子节点，非常高效。","layout":null},"children":[]}]}]},{"data":{"id":"d7zuxjlwusg0","created":1740317119511,"text":"B树与B+树的区别","layout":null},"children":[{"data":{"id":"d7zuxjlwrcw0","created":1740317119511,"text":"1.B+树查询盘的I/O次数减少","layout":null},"children":[{"data":{"id":"d7zuxjlwt800","created":1740317119511,"text":"B树上每个节点存放的都是完整的数据，而B+树的叶子节点上才存储完整的数据，非叶子节点上存储的是主键（或索引）和指针，这意味着后者能在内存中存放更多的索引页，更容易命中缓存，使得查询磁盘的I/O次数减少。","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlwuxc0","created":1740317119511,"text":"2.B+树范围查询能力更强","layout":null},"children":[{"data":{"id":"d7zuxjlwh280","created":1740317119511,"text":"B+树的叶子节点之间通过双向链表进行链接，便于区间查询。","layout":null},"children":[]}]}]},{"data":{"id":"d7zuxjlwwkg0","created":1740317119511,"text":"三层B+树能存储多少数据？","layout":null},"children":[{"data":{"id":"d7zuxjlwlz40","created":1740317119511,"text":"回答模板：计网知识 + B+树知识 + 业务知识","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlxa4w0","created":1740317119512,"text":"为了减少磁盘I/O的次数，B+树层数不宜过高（计网知识）；以三层为计算，假设每条数据记录为1KB，最终大约可以存储2000W条记录（B+树知识）；具体的存储量肯定还是看具体业务的，根据业务大小来决定最终可存储的记录条数（业务知识）。","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlxf4g0","created":1740317119512,"text":"关联知识","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlx7zk0","created":1740317119512,"text":"innoDB引擎中B+树的特点","layout":null},"children":[{"data":{"id":"d7zuxjlx4800","created":1740317119512,"text":"B+树默认数据页为16KB【页的大小可以通过调整参数 innodb_page_size 来修改（通常为 4KB、8KB 或 16KB）】","layout":null},"children":[]},{"data":{"id":"d7zuxjlxc8w0","created":1740317119512,"text":"每个非叶子节点存储的是指向叶子节点的指针和索引键","layout":null},"children":[{"data":{"id":"d7zuxjlxcl40","created":1740317119512,"text":"默认指针6字节，索引键位bitint类型为8字节","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlxfns0","created":1740317119512,"text":"叶子节点存储的是数据记录（聚簇索引存储完整的行）","layout":null},"children":[{"data":{"id":"d7zuxjlxaq80","created":1740317119512,"text":"这里假设数据行大小为1kB","layout":null},"children":[]}]}]},{"data":{"id":"d7zuxjlxh0w0","created":1740317119512,"text":"基于上述特点进行计算：","layout":null},"children":[{"data":{"id":"d7zuxjlx4dc0","created":1740317119512,"text":"第一层【其实就是一个根（头）节点】：一个【指针+索引键】组合要的空间：索引字段+指针共占6+8=14字节","layout":null},"children":[{"data":{"id":"d7zuxjlx0yo0","created":1740317119512,"text":"所以头节点可以存储（16kB*1204）=16384B / 14 = 1170个【【指针+索引键】组合】。所以头节点能指向1170个节点，也就是右1170个子节点","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlxahs0","created":1740317119512,"text":"第二层：同上，一个【指针+索引键】组合要的空间：索引字段+指针共占6+8=14字节","layout":null},"children":[{"data":{"id":"d7zuxjlx8u00","created":1740317119512,"text":"注意，是每个节点都可以指向1170个子节点，所以在等二层，是1170*1170=1368900个叶子结点。","layout":null},"children":[]}]},{"data":{"id":"d7zuxjlx1bc0","created":1740317119512,"text":"最后一层（也就是叶子节点）：前面我们假设每条数据为1KB，所以每页（一页默认16KN）能存储16（16KB/1KB=16条）条数据","layout":null},"children":[{"data":{"id":"d7zuxjlx2x40","created":1740317119512,"text":"最终计算，1368900*16=20000w条数据","layout":null},"children":[]}]}]}]}]},{"data":{"id":"d7zuxjlx7340","created":1740317119512,"text":"详细描述B+树中查询数据的全过程","layout":null},"children":[{"data":{"id":"d7zuxjlxkko0","created":1740317119512,"text":"1.数据从根节点找起，比较（要查询的）数据键值与（非叶子）节点中存储的索引键值，确定数据落在那区间中，从而确定分支，从上到下最终定位到叶子节点：","layout":null},"children":[]},{"data":{"id":"d7zuxjlxuaw0","created":1740317119513,"text":"2.叶子节点中存储实际的数据行，但是一页有16KB大小，存储的数据肯定不止一条","layout":null},"children":[]},{"data":{"id":"d7zuxjly1e80","created":1740317119513,"text":"3.叶子节点中的数据行以组的形式划分，利用页目录结构，通过二分查找可以定位到对应的组","layout":null},"children":[]},{"data":{"id":"d7zuxjlxnxk0","created":1740317119513,"text":"4.定位组后，利用链表遍历即可找到对应的数据行","layout":null},"children":[]},{"data":{"id":"d7zuxjly0ns0","created":1740317119513,"text":"数据页（B+ Tree）的存储结构图","layout":null,"expandState":"expand"},"children":[{"data":{"id":"d7zv2ijmz680","created":1740317509018,"text":""},"children":[]}]}]}]},{"data":{"id":"d7zuxjlxua00","created":1740317119513,"text":"索引类型","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjly35c0","created":1740317119513,"text":"数据结构来看：","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlxzds0","created":1740317119513,"text":"B+树索引"},"children":[{"data":{"id":"d7zuxjlxwv40","created":1740317119513,"text":"树形结构存储数据"},"children":[]},{"data":{"id":"d7zuxjlxzyo0","created":1740317119513,"text":"适用于范围查询和精确查询"},"children":[]},{"data":{"id":"d7zuxjly3g00","created":1740317119513,"text":"Mysql默认索引类型，常用于innoDB和Myisam引擎"},"children":[]}]},{"data":{"id":"d7zuxjlxq1k0","created":1740317119513,"text":"哈希索引"},"children":[{"data":{"id":"d7zuxjlxnps0","created":1740317119513,"text":"哈希表结构"},"children":[]},{"data":{"id":"d7zuxjlxwtk0","created":1740317119513,"text":"适用于等值查询，查询速度快，但不支持范围查询（因为哈希索引不存储数据的顺序）"},"children":[]},{"data":{"id":"d7zuxjlxu080","created":1740317119513,"text":"常用于Memory引擎"},"children":[]}]},{"data":{"id":"d7zuxjlxqoo0","created":1740317119513,"text":"倒排索引（即全文索引 FULL-Text）"},"children":[{"data":{"id":"d7zuxjlxrc00","created":1740317119513,"text":"用于全文搜索，将全文分词"},"children":[]},{"data":{"id":"d7zuxjlydeo0","created":1740317119514,"text":"支持模糊匹配和关键字搜索"},"children":[]},{"data":{"id":"d7zuxjlyk880","created":1740317119514,"text":"适用于大文本字段，如TEXT类型的列"},"children":[]}]},{"data":{"id":"d7zuxjlyeb40","created":1740317119514,"text":"R-树索引（多维空间树）"},"children":[{"data":{"id":"d7zuxjly9uw0","created":1740317119514,"text":"专为多维空间数据（如地理坐标）设计，适用于空间查询（例如，计算地理位置的最近距离、区域查询等）"},"children":[]},{"data":{"id":"d7zuxjly74g0","created":1740317119514,"text":"常用于存储和查询地理信息系统（GIS）中的空间数据。"},"children":[]}]}]},{"data":{"id":"d7zuxjlyio00","created":1740317119514,"text":"从常见的innoDB B+树索引的角度来看，可以分为：","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlyr2w0","created":1740317119514,"text":"聚簇索引：（Clustered Index）"},"children":[]},{"data":{"id":"d7zuxjly7eo0","created":1740317119514,"text":"非聚簇索引：（Non-clustered Index）"},"children":[]}]},{"data":{"id":"d7zuxjlycig0","created":1740317119514,"text":"从索引性质的角度来看：","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlyd800","created":1740317119514,"text":"普通索引（二级索引、辅助索引）：一般指非主键索引且非唯一索引。"},"children":[]},{"data":{"id":"d7zuxjlykaw0","created":1740317119514,"text":"主键索引：表中的每一行数据都有唯一的主键。每个表只能有一个主键索引，且主键值不能为 NULL。InnoDB 中主键索引是聚簇索引结构实现的。"},"children":[]},{"data":{"id":"d7zuxjlyn5s0","created":1740317119514,"text":"联合索引：由多个列组成的索引，适用于多列的查询条件，能够提高包含多个条件的查询的性能。联合索引中的列是按照指定顺序排列的"},"children":[]},{"data":{"id":"d7zuxjlyops0","created":1740317119514,"text":"唯一索引：保证索引列中的值是唯一的，可以有效防止重复数据的插入。唯一索引允许 NULL 值，但一个列中可以有多个 NULL。"},"children":[]},{"data":{"id":"d7zuxjlyjlc0","created":1740317119514,"text":"全文索引：用于全文搜索，支持对长文本字段（如 TEXT 类型）进行关键字查找，支持自然语言处理、模糊匹配等操作。适用于需要对文本内容进行复杂搜索的场景。"},"children":[]},{"data":{"id":"d7zuxjly6yw0","created":1740317119514,"text":"空间索引：用于空间数据（如地图上的经纬度坐标等）查询。通常使用 R-树结构，适合多维数据的查询，如区域查询和最近距离查询，主要用于 MyISAM 和 InnoDB 存储引擎中的地理信息数据。"},"children":[]}]}]},{"data":{"id":"d7zuxjlyny80","created":1740317119514,"text":"索引一定会生效吗？如何排查索引效果？","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjlybnk0","created":1740317119514,"text":"答1：索引不一定生效，因为本质是："},"children":[{"data":{"id":"d7zuxjlytsg0","created":1740317119515,"text":"走索引的效率是否高于全表扫描（即查询优化器如何选择执行计划）"},"children":[{"data":{"id":"d7zuxjlzd400","created":1740317119515,"text":"是否用上索引是根据 MySQL 成本计算决定的（即查询优化器如何选择执行计划）："},"children":[{"data":{"id":"d7zuxjlz2b40","created":1740317119515,"text":"优化器成本计算方式如下："},"children":[{"data":{"id":"d7zuxjlzc0o0","created":1740317119515,"text":"终的成本计算 =  扫描行数 * 0.2 + 数据长度/16kb = 成本"},"children":[]},{"data":{"id":"d7zuxjlz9140","created":1740317119515,"text":"1.I/O成本"},"children":[{"data":{"id":"d7zuxjlz6e00","created":1740317119515,"text":"数据从磁盘加载到内存的成本。因为mysql以页（1页默认为16KB）的形式读取数据，即使你只要一条数据，实际读取的还是整页的数据。"},"children":[]}]},{"data":{"id":"d7zuxjlyuco0","created":1740317119515,"text":"2.CPU成本"},"children":[{"data":{"id":"d7zuxjlz58w0","created":1740317119515,"text":"数据从磁盘提取到内存后，需要比较、排序等操作，这些操作会占用CPU资源，所以优化器以行为成本，一行成本为0.2."},"children":[]}]}]},{"data":{"id":"d7zuxjlyszk0","created":1740317119515,"text":"执行优化的计划的步骤如下："},"children":[{"data":{"id":"d7zuxjlz6000","created":1740317119515,"text":"1.将sql语句解析为解析树"},"children":[]},{"data":{"id":"d7zuxjlz9b40","created":1740317119515,"text":"2.预处理，包括语法检查、权限验证、常量表达式计算等等"},"children":[]},{"data":{"id":"d7zuxjlz5t40","created":1740317119515,"text":"3.生成多个执行计划，选择成本最低的执行计划"},"children":[]}]},{"data":{"id":"d7zuxjlyskg0","created":1740317119515,"text":"如何优化查询优化器呢："},"children":[{"data":{"id":"d7zuxjlz3a00","created":1740317119515,"text":"1.查询重写"},"children":[]},{"data":{"id":"d7zuxjlz1oo0","created":1740317119515,"text":"2.表连接优化"},"children":[]}]}]}]},{"data":{"id":"d7zuxjlywm80","created":1740317119515,"text":"或者是索引是否被正确使用"},"children":[{"data":{"id":"d7zuxjlyvco0","created":1740317119515,"text":"注意：索引失效的时候，使用全表扫描，全表扫描 = 全扫描主键索引（等价于没用上索引，但是实际上用了主键索引。实际上，innoDB里面查找任何数据，都要用索引）"},"children":[]},{"data":{"id":"d7zuxjlz94w0","created":1740317119515,"text":"什么叫使用了索引："},"children":[{"data":{"id":"d7zuxjlz71c0","created":1740317119515,"text":"1.利用主键索引快速查找"},"children":[]},{"data":{"id":"d7zuxjlzv5k0","created":1740317119516,"text":"2.利用二级索引快速查找"},"children":[]},{"data":{"id":"d7zuxjlzvds0","created":1740317119516,"text":"3.全扫描二级索引进行查找"},"children":[]}]},{"data":{"id":"d7zuxjlzqig0","created":1740317119516,"text":"失效的可能原因："},"children":[{"data":{"id":"d7zuxjlzfrk0","created":1740317119516,"text":"1.不符合Mysql索引的最左前缀匹配原则是什么："},"children":[{"data":{"id":"d7zuxjlzsog0","created":1740317119516,"text":"LIKE 模糊查询，'%xx' 或 LIKE '%xx%' 无法利用索引的前缀特性，仅允许右模糊 'xx%'"},"children":[]},{"data":{"id":"d7zuxjlzfpc0","created":1740317119516,"text":"or的随意使用"},"children":[]}]},{"data":{"id":"d7zuxjlzja80","created":1740317119516,"text":"2.在索引列上使用函数/运算："},"children":[{"data":{"id":"d7zuxjlzg9c0","created":1740317119516,"text":"隐式字符编码转换"},"children":[]}]},{"data":{"id":"d7zuxjlzf940","created":1740317119516,"text":"3.表中2个不同的字段进行比较："},"children":[{"data":{"id":"d7zuxjlzmg00","created":1740317119516,"text":"例如这样的SQL :select * from user where id > age; ，将 id 跟 age 字段做了比较，索引失效"},"children":[]}]},{"data":{"id":"d7zuxjlzng80","created":1740317119516,"text":"4.使用了 order by"},"children":[{"data":{"id":"d7zuxjlzlgg0","created":1740317119516,"text":"当 order by （排序操作）后面跟的 不是主键 或者 不是覆盖索引 会导致不走索引"},"children":[]}]}]}]}]},{"data":{"id":"d7zuxjlzlkg0","created":1740317119516,"text":"答2：使用EXPLAIN语句排查索引效果"},"children":[{"data":{"id":"d7zuxjlzhls0","created":1740317119516,"text":"EXPLANIN语句"},"children":[{"data":{"id":"d7zuxjlzg5k0","created":1740317119516,"text":"EXPLAIN 是 MySQL 中用于分析 SQL 查询执行计划的工具。通过使用 EXPLAIN，我们可以查看 MySQL 如何执行查询，包括哪些索引被使用、查询的执行顺序、扫描的行数等信息"},"children":[]},{"data":{"id":"d7zuxjlzqc00","created":1740317119516,"text":"以 EXPLAIN SELECT * FROM users WHERE age > 30; 为例子："},"children":[]},{"data":{"id":"d7zuxjlzeww0","created":1740317119516,"text":"主要看以下几个参数："},"children":[{"data":{"id":"d7zuxjm0bbs0","created":1740317119517,"text":"id：查询的执行顺序的标识符，值越大优先级越高。简单查询的 id 通常为 1，复杂查询（如包含子查询或 UNION）的 id 会有多个。"},"children":[]},{"data":{"id":"d7zuxjm03tc0","created":1740317119517,"text":"select_type（重要）：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。"},"children":[]},{"data":{"id":"d7zuxjm0dvk0","created":1740317119517,"text":"table：查询的数据表。"},"children":[]},{"data":{"id":"d7zuxjm0fow0","created":1740317119517,"text":"type（重要）：访问类型，如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）等。一般来说，性能从好到差的顺序是：const > eq_ref > ref > range > index > ALL。详细如下："},"children":[{"data":{"id":"d7zuxjlzzmo0","created":1740317119517,"text":"system：表示查询的表只有一行（系统表）。这是一个特殊的情况，不常见。"},"children":[]},{"data":{"id":"d7zuxjm0e9k0","created":1740317119517,"text":"const：表示查询的表最多只有一行匹配结果。这通常发生在查询条件是主键或唯一索引，并且是常量比较。"},"children":[]},{"data":{"id":"d7zuxjlzzsg0","created":1740317119517,"text":"eq_ref：表示对于每个来自前一张表的行，MySQL 仅访问一次这个表。这通常发生在连接查询中使用主键或唯一索引的情况下。"},"children":[]},{"data":{"id":"d7zuxjm02jk0","created":1740317119517,"text":"ref：MySQL 使用非唯一索引扫描来查找行。查询条件使用的索引是非唯一的（如普通索引）。"},"children":[]},{"data":{"id":"d7zuxjm03og0","created":1740317119517,"text":"range：表示 MySQL 会扫描表的一部分，而不是全部行。范围扫描通常出现在使用索引的范围查询中（如 BETWEEN、>, <, >=, <=）。"},"children":[]},{"data":{"id":"d7zuxjm0ctc0","created":1740317119517,"text":"index：表示 MySQL 扫描索引中的所有行，而不是表中的所有行。即使索引列的值覆盖查询，也需要扫描整个索引。"},"children":[]},{"data":{"id":"d7zuxjm02cw0","created":1740317119517,"text":"all（性能最差）：表示 MySQL 需要扫描表中的所有行，即全表扫描。通常出现在没有索引的查询条件中。"},"children":[]}]},{"data":{"id":"d7zuxjm051s0","created":1740317119517,"text":"possible_keys：可能用到的索引。"},"children":[]},{"data":{"id":"d7zuxjlzyu80","created":1740317119517,"text":"key（重要）：这个属性显示了查询使用的索引，如果查询使用了索引，则会显示索引的名称。如果这个值是 NULL，则表示查询没有使用索引。"},"children":[]},{"data":{"id":"d7zuxjm0dnc0","created":1740317119517,"text":"key_len：用到索引的长度。"},"children":[]},{"data":{"id":"d7zuxjm0jbs0","created":1740317119517,"text":"ref：显示索引的哪一列被使用。"},"children":[]},{"data":{"id":"d7zuxjm00m00","created":1740317119517,"text":"rows（重要）：估计要扫描的行数，值越小越好。"},"children":[]},{"data":{"id":"d7zuxjm0eg80","created":1740317119517,"text":"filtered：显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。"},"children":[]},{"data":{"id":"d7zuxjm0uvk0","created":1740317119518,"text":"Extra（重要）：额外信息，如 Using index（表示使用覆盖索引）、Using where（表示使用 WHERE 条件进行过滤）、Using temporary（表示使用临时表）、Using filesort（表示需要额外的排序步骤）。"},"children":[]}]}]}]}]},{"data":{"id":"d7zuxjm0uzc0","created":1740317119518,"text":"Mysql创建索引时需要注意什么","expandState":"collapse"},"children":[{"data":{"id":"d7zuxjm12a80","created":1740317119518,"text":"1.选择合适的列"},"children":[{"data":{"id":"d7zuxjm14eo0","created":1740317119518,"text":"高选择性列优先"},"children":[{"data":{"id":"d7zuxjm0p0g0","created":1740317119518,"text":"索引应该建在选择性高的列上，也就是重复值少的列上。例如，用户表上，“身份证“就很合适，因为每个用户的身份证号都是独一无二的；像”性别“这种只有”男“、”女“2种取值的列，建立索引的收益很小，查询数据库时仍要遍历大量数据（这个不绝对，如果数据的比例差距大的时候，比如男女比例为9：1的时候，建立索引是有优化的）。"},"children":[]}]},{"data":{"id":"d7zuxjm0kfc0","created":1740317119518,"text":"频繁用于查询条件的列"},"children":[{"data":{"id":"d7zuxjm0qc80","created":1740317119518,"text":"常在 WHERE、JOIN、ORDER BY 及 GROUP BY 子句中出现的列，创建索引能显著加速查询。例如电商订单表，”下单时间“字段常用于查询某个时间段的订单，对此列建立索引，相关时间段订单查询速度会大幅提升。"},"children":[]}]},{"data":{"id":"d7zuxjm0kiw0","created":1740317119518,"text":"前缀索引"},"children":[{"data":{"id":"d7zuxjm0ly80","created":1740317119518,"text":"对于很长的字符串类型列（如 VARCHAR、TEXT），若完整建索引太占空间，可考虑前缀索引。例如，一篇文章的标题列 article_title， 可以只取前几个字符建索引，在节省空间的同时，也能对常用查询起到加速效果。"},"children":[]}]}]},{"data":{"id":"d7zuxjm0pyw0","created":1740317119518,"text":"2.索引数量把控"},"children":[{"data":{"id":"d7zuxjm0ncw0","created":1740317119518,"text":"避免过度索引"},"children":[{"data":{"id":"d7zuxjm13ns0","created":1740317119518,"text":"主要从2个角度考虑：时间成本和空间成本"},"children":[{"data":{"id":"d7zuxjm0z1c0","created":1740317119518,"text":"时间成本：数据增删改的时候，如果有对应的索引，数据库要同步更新索引（B+树的叶子节点可能会有页分裂、页合并等操作），索引过多会拖慢写入操作，时间开销大。"},"children":[]},{"data":{"id":"d7zuxjm0uww0","created":1740317119518,"text":"空间成本：底层为B+树，以页为单位（一页默认16KB），每个二级索引都会创建一个B+树，占用额外的磁盘空间。"},"children":[]}]}]},{"data":{"id":"d7zuxjm0nko0","created":1740317119518,"text":"复合索引的顺序"},"children":[]}]},{"data":{"id":"d7zuxjm0uu80","created":1740317119518,"text":"3.索引的维护与更新"},"children":[]},{"data":{"id":"d7zuxjm0qqw0","created":1740317119518,"text":"4.存储引擎特性"},"children":[]}]}]},{"data":{"id":"d7zuydg5h6g0","created":1740317184466,"text":"MySQL种如何进行SQL优化","expandState":"collapse"},"children":[{"data":{"id":"d7zuydg6fuo0","created":1740317184468,"text":"1.高级工具与监控"},"children":[{"data":{"id":"d7zuydg79i00","created":1740317184469,"text":"1.通过explain进行执行计划分析（答2：使用EXPLAIN语句排查索引效果）"},"children":[]},{"data":{"id":"d7zuydg6qio0","created":1740317184469,"text":"2.慢查询（慢SQL）日志"},"children":[{"data":{"id":"d7zuydg6ycg0","created":1740317184469,"text":"开启慢查询日志定位性能瓶颈"},"children":[]},{"data":{"id":"d7zuydg77og0","created":1740317184469,"text":"慢SQL使用如下图："},"children":[]}]}]},{"data":{"id":"d7zuydg6v7k0","created":1740317184469,"text":"2.索引优化"},"children":[{"data":{"id":"d7zuydg77340","created":1740317184469,"text":"1.合理设计索引（Mysql创建索引时需要注意什么）"},"children":[]},{"data":{"id":"d7zuydg6st40","created":1740317184469,"text":"2.索引是否被正确使用（或者是索引是否被正确使用）"},"children":[]},{"data":{"id":"d7zuydg71b40","created":1740317184469,"text":"2.覆盖索引优化（1.索引覆盖)"},"children":[]},{"data":{"id":"d7zuydg7bug0","created":1740317184470,"text":"3.索引下推优化（2.索引下推(icp)）"},"children":[]}]},{"data":{"id":"d7zuydg7j6o0","created":1740317184470,"text":"3.查询语句优化"},"children":[{"data":{"id":"d7zuydg7dgo0","created":1740317184470,"text":"1）避免 SELECT * ，只查询必要的字段"},"children":[]},{"data":{"id":"d7zuydg7pbs0","created":1740317184470,"text":"2）避免在 SQL 中进行函数计算等操作，使得无法命中索引"},"children":[]},{"data":{"id":"d7zuydg7feg0","created":1740317184470,"text":"3）避免使用 %LIKE，导致全表扫描"},"children":[]},{"data":{"id":"d7zuydg7gfc0","created":1740317184470,"text":"4）注意联合索引需满足最左匹配原则"},"children":[]},{"data":{"id":"d7zuydg7fzk0","created":1740317184470,"text":"5）不要对无索引字段进行排序操作"},"children":[]},{"data":{"id":"d7zuydg7sdc0","created":1740317184470,"text":"6）连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描"},"children":[]}]},{"data":{"id":"d7zuydg7sso0","created":1740317184470,"text":"4.额外补充：缓存、业务层面的表结构设计都可以。"},"children":[]}]},{"data":{"id":"d7zuygz4rw80","created":1740317192144,"text":"关于MySQL优化"},"children":[]}]},"template":"default","theme":"classic","version":"1.4.43"}